import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { PrismAgentVersion } from '@/context/PrismAgentContext';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useToast } from '@/hooks/use-toast';
import { Loader2, PlugZap, RefreshCw, Server, Terminal as TerminalIcon } from 'lucide-react';
import { GeneratedApp } from '@/services/codeGenerationService';
import '@xterm/xterm/css/xterm.css';

type RuntimeKind = 'node' | 'python';

type WebContainerInstance = import('@webcontainer/api').WebContainer;
type FileSystemTree = import('@webcontainer/api').FileSystemTree;
type WebContainerProcess = import('@webcontainer/api').WebContainerProcess;
type XTerm = import('@xterm/xterm').Terminal;
type FitAddonType = import('@xterm/addon-fit').FitAddon;

interface PyodideFileSystem {
  stat: (path: string) => { mode: number } | undefined;
  isDir: (mode: number) => boolean;
  readdir: (path: string) => string[];
  mkdir: (path: string) => void;
  unlink: (path: string) => void;
  rmdir: (path: string) => void;
  writeFile: (path: string, content: string) => void;
  readFile: (path: string, options: { encoding: 'utf8' }) => string;
}

interface PyodideInstance {
  FS: PyodideFileSystem;
  loadPackage: (name: string) => Promise<void>;
  runPythonAsync: (code: string) => Promise<unknown>;
}

declare global {
  interface Window {
    loadPyodide?: (config?: Record<string, unknown>) => Promise<unknown>;
  }
}

interface FileEntry {
  path: string;
  content: string;
}

interface PrismAgentTerminalProps {
  activeVersion?: PrismAgentVersion;
}

const NODE_WORKSPACE_DIR = '/workspace';
const PYTHON_PREVIEW_FILE = '/workspace/prism_preview.html';

const buildFileEntries = (app: GeneratedApp): FileEntry[] => {
  const entries = new Map<string, string>();

  (app.files || []).forEach((file) => {
    if (!file.path) return;
    entries.set(file.path, file.content ?? '');
  });

  if (app.html && app.html.trim().length > 0 && !entries.has('index.html')) {
    entries.set('index.html', app.html);
  }

  if (app.css && app.css.trim().length > 0 && !entries.has('styles.css')) {
    entries.set('styles.css', app.css);
  }

  if (app.javascript && app.javascript.trim().length > 0 && !entries.has('script.js')) {
    entries.set('script.js', app.javascript);
  }

  if (!entries.has('README.md')) {
    const stackLines: string[] = [];
    if (app.stack?.language) stackLines.push(`- Language: ${app.stack.language}`);
    if (app.stack?.framework) stackLines.push(`- Framework: ${app.stack.framework}`);
    if (app.stack?.libraries?.length) stackLines.push(`- Libraries: ${app.stack.libraries.join(', ')}`);
    if (app.stack?.tooling?.length) stackLines.push(`- Tooling: ${app.stack.tooling.join(', ')}`);

    const details = stackLines.length > 0 ? `\n${stackLines.join('\n')}` : '';
    const features = (app.features || []).map((feature) => `- ${feature}`).join('\n');

    entries.set(
      'README.md',
      `# Prism Agent build\n\n${app.description || 'Generated by Prism Agent.'}\n\n## Stack${details}\n\n## Features\n${features || '- Generated feature overview'}\n`
    );
  }

  return Array.from(entries.entries()).map(([path, content]) => ({ path, content }));
};

const buildFileTree = (files: FileEntry[]): FileSystemTree => {
  const tree: FileSystemTree = {};

  files.forEach(({ path, content }) => {
    if (!path) return;
    const cleanPath = path.replace(/^\/+/, '');
    const segments = cleanPath.split('/');
    let current: FileSystemTree = tree;

    segments.forEach((segment, index) => {
      if (!segment) return;

      if (index === segments.length - 1) {
        current[segment] = { file: { contents: content } };
        return;
      }

      if (!current[segment]) {
        current[segment] = { directory: {} };
      }

      current = (current[segment] as { directory: FileSystemTree }).directory;
    });
  });

  return tree;
};

const PrismAgentTerminal = ({ activeVersion }: PrismAgentTerminalProps) => {
  const { toast } = useToast();
  const containerRef = useRef<HTMLDivElement | null>(null);
  const termRef = useRef<XTerm | null>(null);
  const fitAddonRef = useRef<FitAddonType | null>(null);
  const commandBufferRef = useRef<string>('');
  const nodeContainerRef = useRef<WebContainerInstance | null>(null);
  const pythonRuntimeRef = useRef<PyodideInstance | null>(null);
  const activeProcessRef = useRef<WebContainerProcess | null>(null);
  const decoderRef = useRef(new TextDecoder());

  const [runtime, setRuntime] = useState<RuntimeKind>('node');
  const [terminalReady, setTerminalReady] = useState(false);
  const [runtimeBooting, setRuntimeBooting] = useState(false);
  const [isSyncing, setIsSyncing] = useState(false);
  const [statusMessage, setStatusMessage] = useState('Select a runtime and sync your project files to begin.');
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [pythonPreviewHtml, setPythonPreviewHtml] = useState<string | null>(null);

  const activeApp = activeVersion?.app;

  const promptLabel = useMemo(() => (runtime === 'node' ? 'node:~/workspace$ ' : 'python:~/workspace$ '), [runtime]);

  const write = useCallback((message: string) => {
    if (!termRef.current) return;
    termRef.current.write(message);
  }, []);

  const showPrompt = useCallback(() => {
    if (!termRef.current) return;
    termRef.current.write(`\r\n${promptLabel}`);
    commandBufferRef.current = '';
  }, [promptLabel]);

  const disposeActiveProcess = useCallback(() => {
    if (!activeProcessRef.current) return;
    try {
      activeProcessRef.current.kill?.();
    } catch (error) {
      console.warn('Failed to terminate process', error);
    }
    activeProcessRef.current = null;
  }, []);

  const updatePythonPreview = useCallback(() => {
    if (!pythonRuntimeRef.current) {
      setPythonPreviewHtml(null);
      return;
    }

    try {
      const html = pythonRuntimeRef.current.FS.readFile(PYTHON_PREVIEW_FILE, { encoding: 'utf8' });
      setPythonPreviewHtml(html);
      setPreviewUrl(null);
    } catch (error) {
      setPythonPreviewHtml(null);
    }
  }, []);

  const ensureNodeContainer = useCallback(async () => {
    if (typeof window === 'undefined') return null;
    if (nodeContainerRef.current) return nodeContainerRef.current;

    setRuntimeBooting(true);
    setStatusMessage('Booting WebContainer runtime...');

    try {
      const { WebContainer } = await import('@webcontainer/api');
      const container = await WebContainer.boot();

      container.on('server-ready', (_port, url) => {
        setPreviewUrl(url);
        setPythonPreviewHtml(null);
        write(`\r\n# Server ready: ${url}`);
      });

      container.on('server-crash', (error) => {
        write(`\r\n# Server crashed: ${String(error)}`);
      });

      nodeContainerRef.current = container;
      return container;
    } catch (error) {
      console.error('Failed to boot WebContainer', error);
      toast({
        title: 'WebContainer failed to start',
        description: 'Falling back to local runtime instructions.',
        variant: 'destructive',
      });
      return null;
    } finally {
      setRuntimeBooting(false);
    }
  }, [toast, write]);

  const ensurePythonRuntime = useCallback(async (): Promise<PyodideInstance | null> => {
    if (typeof window === 'undefined') return null;
    if (pythonRuntimeRef.current) return pythonRuntimeRef.current;

    setRuntimeBooting(true);
    setStatusMessage('Loading Pyodide runtime...');

    try {
      if (!window.loadPyodide) {
        await new Promise<void>((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js';
          script.onload = () => resolve();
          script.onerror = () => reject(new Error('Failed to load Pyodide script'));
          document.body.appendChild(script);
        });
      }

      const pyodide = (await window.loadPyodide({
        stdout: (text: string) => write(text),
        stderr: (text: string) => write(text),
      })) as PyodideInstance;

      await pyodide.loadPackage('micropip');
      pythonRuntimeRef.current = pyodide;
      return pyodide;
    } catch (error) {
      console.error('Failed to boot Pyodide', error);
      toast({
        title: 'Python runtime failed to load',
        description: 'Review the runtime instructions to run the project locally.',
        variant: 'destructive',
      });
      return null;
    } finally {
      setRuntimeBooting(false);
    }
  }, [toast, write]);

  const syncNodeWorkspace = useCallback(
    async (app: GeneratedApp) => {
      const container = await ensureNodeContainer();
      if (!container) return;

      setIsSyncing(true);
      setStatusMessage('Syncing project files into WebContainer...');

      try {
        const files = buildFileEntries(app);
        const tree = buildFileTree(files);

        await container.mount({
          workspace: {
            directory: tree,
          },
        });

        write(`\r\n# Synced ${files.length} file${files.length === 1 ? '' : 's'} into ${NODE_WORKSPACE_DIR}`);
        setStatusMessage('WebContainer workspace ready. Install dependencies and start your dev server.');
      } catch (error) {
        console.error('Failed to sync WebContainer workspace', error);
        toast({
          title: 'Failed to sync workspace',
          description: 'Could not copy files into the WebContainer runtime.',
          variant: 'destructive',
        });
      } finally {
        setIsSyncing(false);
      }
    },
    [ensureNodeContainer, toast, write]
  );

  const clearPythonDirectory = useCallback((FS: PyodideFileSystem, path: string) => {
    try {
      const stats = FS.stat(path);
      if (!stats) return;
      if (FS.isDir(stats.mode)) {
        FS.readdir(path)
          .filter((entry) => entry !== '.' && entry !== '..')
          .forEach((entry) => {
            const childPath = `${path}/${entry}`;
            const childStats = FS.stat(childPath);
            if (childStats && FS.isDir(childStats.mode)) {
              clearPythonDirectory(FS, childPath);
              FS.rmdir(childPath);
            } else {
              FS.unlink(childPath);
            }
          });
      } else {
        FS.unlink(path);
      }
    } catch (error) {
      console.warn('Failed to clear Pyodide directory', error);
    }
  }, []);

  const ensurePythonDirectory = useCallback((FS: PyodideFileSystem, dir: string) => {
    const parts = dir.split('/').filter(Boolean);
    let current = '';
    parts.forEach((part) => {
      current = `${current}/${part}`;
      try {
        FS.mkdir(current);
      } catch (error) {
        // Directory may already exist
      }
    });
  }, []);

  const syncPythonWorkspace = useCallback(
    async (app: GeneratedApp) => {
      const pyodide = await ensurePythonRuntime();
      if (!pyodide) return;

      setIsSyncing(true);
      setStatusMessage('Syncing project files into Pyodide...');

      try {
        const FS = pyodide.FS;
        ensurePythonDirectory(FS, NODE_WORKSPACE_DIR);
        clearPythonDirectory(FS, NODE_WORKSPACE_DIR);

        const files = buildFileEntries(app);

        files.forEach(({ path, content }) => {
          const cleanPath = path.replace(/^\/+/, '');
          const fullPath = `${NODE_WORKSPACE_DIR}/${cleanPath}`;
          const directory = fullPath.split('/').slice(0, -1).join('/');
          ensurePythonDirectory(FS, directory);
          FS.writeFile(fullPath, content);
        });

        setStatusMessage('Pyodide workspace ready. Use pip install and python commands, then write prism_preview.html to refresh the preview.');
        write(`\r\n# Synced ${files.length} file${files.length === 1 ? '' : 's'} into ${NODE_WORKSPACE_DIR}`);
        updatePythonPreview();
      } catch (error) {
        console.error('Failed to sync Pyodide workspace', error);
        toast({
          title: 'Failed to sync Python workspace',
          description: 'Unable to copy files into the Pyodide runtime.',
          variant: 'destructive',
        });
      } finally {
        setIsSyncing(false);
      }
    },
    [clearPythonDirectory, ensurePythonDirectory, ensurePythonRuntime, toast, updatePythonPreview, write]
  );

  const runNodeCommand = useCallback(
    async (command: string) => {
      const container = await ensureNodeContainer();
      if (!container) return;

      setStatusMessage(`Running: ${command}`);
      const shell = await container.spawn('bash', {
        args: ['-lc', `cd ${NODE_WORKSPACE_DIR} && ${command}`],
      });

      activeProcessRef.current = shell;
      const reader = shell.output.getReader();

      const pumpOutput = async () => {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) {
            write(decoderRef.current.decode(value));
          }
        }
      };

      const outputPromise = pumpOutput();
      const exitCode = await shell.exit;
      await outputPromise;

      activeProcessRef.current = null;
      if (exitCode !== 0) {
        write(`\r\n# Process exited with code ${exitCode}`);
      }
      setStatusMessage('WebContainer runtime ready.');
    },
    [ensureNodeContainer, write]
  );

  const runPythonCommand = useCallback(
    async (command: string) => {
      const pyodide = await ensurePythonRuntime();
      if (!pyodide) return;

      const trimmed = command.trim();
      if (!trimmed) return;

      setStatusMessage(`Running: ${command}`);

      if (trimmed === 'clear') {
        termRef.current?.clear();
        setStatusMessage('Cleared terminal output.');
        return;
      }

      if (trimmed.startsWith('pip install')) {
        const packages = trimmed.replace(/^pip install\s+/, '').split(/\s+/).filter(Boolean);
        if (!packages.length) {
          write('\r\n# Specify at least one package to install.');
          setStatusMessage('Awaiting command.');
          return;
        }

        const installList = packages.map((pkg) => `"${pkg}"`).join(', ');
        await pyodide.runPythonAsync(
          `import micropip\nawait micropip.install([${installList}])`
        );
        setStatusMessage('Packages installed.');
        return;
      }

      if (/^python(3)?\s+/.test(trimmed)) {
        const target = trimmed.replace(/^python(3)?\s+/, '').trim();
        const fullPath = target.startsWith('/') ? target : `${NODE_WORKSPACE_DIR}/${target}`;
        await pyodide.runPythonAsync(
          `import runpy\nrunpy.run_path('${fullPath}', run_name='__main__')`
        );
        updatePythonPreview();
        setStatusMessage('Script executed. Update prism_preview.html to refresh the inline preview.');
        return;
      }

      const result = await pyodide.runPythonAsync(trimmed);
      if (typeof result === 'string' && result.length > 0) {
        write(`\r\n${result}`);
      }
      updatePythonPreview();
      setStatusMessage('Python runtime ready.');
    },
    [ensurePythonRuntime, updatePythonPreview, write]
  );

  const runCommand = useCallback(
    async (command: string) => {
      const trimmed = command.trim();
      if (!trimmed) {
        showPrompt();
        return;
      }

      if (trimmed === 'clear') {
        termRef.current?.clear();
        showPrompt();
        return;
      }

      try {
        if (runtime === 'node') {
          await runNodeCommand(trimmed);
        } else {
          await runPythonCommand(trimmed);
        }
      } catch (error) {
        console.error('Runtime command failed', error);
        toast({
          title: 'Command failed',
          description: error instanceof Error ? error.message : String(error),
          variant: 'destructive',
        });
        write(`\r\n# ${error instanceof Error ? error.message : String(error)}`);
      } finally {
        showPrompt();
      }
    },
    [runNodeCommand, runPythonCommand, runtime, showPrompt, toast, write]
  );

  const initTerminal = useCallback(async (): Promise<(() => void) | void> => {
    if (termRef.current || typeof window === 'undefined') {
      return;
    }

    const [{ Terminal }, { FitAddon }, { WebLinksAddon }] = await Promise.all([
      import('@xterm/xterm'),
      import('@xterm/addon-fit'),
      import('@xterm/addon-web-links'),
    ]);

    const terminal = new Terminal({
      convertEol: true,
      cursorBlink: true,
      fontSize: 13,
      fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
      theme: {
        background: '#050505',
        foreground: '#f8fafc',
        cursor: '#38bdf8',
      },
    });

    const fitAddon = new FitAddon();
    terminal.loadAddon(fitAddon);
    terminal.loadAddon(new WebLinksAddon());

    termRef.current = terminal;
    fitAddonRef.current = fitAddon;

    if (containerRef.current) {
      terminal.open(containerRef.current);
      fitAddon.fit();
    }

    terminal.writeln('Prism Agent runtime terminal ready.');
    terminal.writeln('Install dependencies, run build tools, and host previews for any stack.');
    terminal.write(promptLabel);

    commandBufferRef.current = '';
    terminal.onData((data: string) => {
      const code = data.charCodeAt(0);

      if (code === 13) {
        const commandValue = commandBufferRef.current;
        terminal.write('\r\n');
        commandBufferRef.current = '';
        runCommand(commandValue);
        return;
      }

      if (code === 127) {
        if (commandBufferRef.current.length > 0) {
          commandBufferRef.current = commandBufferRef.current.slice(0, -1);
          terminal.write('\b \b');
        }
        return;
      }

      if (code === 3) {
        disposeActiveProcess();
        terminal.writeln('^C');
        showPrompt();
        return;
      }

      commandBufferRef.current += data;
      terminal.write(data);
    });

    const handleResize = () => {
      try {
        fitAddon.fit();
      } catch (error) {
        // Ignore resize errors
      }
    };

    window.addEventListener('resize', handleResize);
    setTerminalReady(true);

    return () => {
      window.removeEventListener('resize', handleResize);
      disposeActiveProcess();
      terminal.dispose();
      termRef.current = null;
    };
  }, [disposeActiveProcess, promptLabel, runCommand, showPrompt]);

  const syncActiveWorkspace = useCallback(async () => {
    if (!activeApp) {
      setStatusMessage('Generate a build to sync files into the runtime.');
      return;
    }

    if (runtime === 'node') {
      await syncNodeWorkspace(activeApp);
    } else {
      await syncPythonWorkspace(activeApp);
    }
  }, [activeApp, runtime, syncNodeWorkspace, syncPythonWorkspace]);

  useEffect(() => {
    let dispose: (() => void) | void;

    initTerminal().then((cleanup) => {
      dispose = cleanup;
    });

    return () => {
      if (dispose) {
        dispose();
      }
    };
  }, [initTerminal]);

  useEffect(() => {
    if (!terminalReady) return;
    syncActiveWorkspace();
  }, [activeVersion?.id, runtime, terminalReady, syncActiveWorkspace]);

  useEffect(() => {
    setPreviewUrl(null);
    setPythonPreviewHtml(null);
  }, [runtime]);

  useEffect(() => {
    if (!activeApp?.stack?.language) return;
    const language = activeApp.stack.language.toLowerCase();
    if (language.includes('python')) {
      setRuntime((current) => (current === 'python' ? current : 'python'));
    }
  }, [activeApp?.stack?.language, activeVersion?.id]);

  useEffect(() => {
    return () => {
      disposeActiveProcess();
      nodeContainerRef.current?.teardown?.();
    };
  }, [disposeActiveProcess]);

  return (
    <Card className="border border-border/40 bg-background/70 backdrop-blur">
      <CardHeader>
        <div className="flex flex-wrap items-center justify-between gap-3">
          <CardTitle className="flex items-center gap-2 text-sm">
            <TerminalIcon className="h-4 w-4 text-primary" /> Runtime terminal
          </CardTitle>
          {activeApp && (
            <div className="flex items-center gap-2">
              <Select
                value={runtime}
                onValueChange={(value) => setRuntime(value as RuntimeKind)}
                disabled={runtimeBooting || isSyncing}
              >
                <SelectTrigger className="h-8 w-[220px] text-xs">
                  <SelectValue placeholder="Select runtime" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="node">Node.js (WebContainer)</SelectItem>
                  <SelectItem value="python">Python (Pyodide)</SelectItem>
                </SelectContent>
              </Select>
              <Button
                type="button"
                size="sm"
                variant="outline"
                className="flex items-center gap-2"
                onClick={syncActiveWorkspace}
                disabled={runtimeBooting || isSyncing}
              >
                {isSyncing ? <Loader2 className="h-4 w-4 animate-spin" /> : <RefreshCw className="h-4 w-4" />}
                Sync files
              </Button>
            </div>
          )}
        </div>
        <p className="mt-2 text-xs text-muted-foreground">
          Install dependencies, run dev servers, and preview projects directly inside Prism Agent for any supported stack.
        </p>
      </CardHeader>
      <CardContent className="space-y-4">
        {!activeApp ? (
          <div className="rounded-lg border border-dashed border-border/40 bg-background/40 p-6 text-center text-sm text-muted-foreground">
            Generate a build to access the runtime terminal and environment syncing tools.
          </div>
        ) : (
          <>
            <div className="rounded-lg border border-border/30 bg-black/80 p-3">
              <div ref={containerRef} className="h-64" />
            </div>
            <div className="space-y-2 text-xs text-muted-foreground">
              <div className="flex items-center gap-2">
                <PlugZap className="h-4 w-4 text-primary" />
                <span>{statusMessage}</span>
              </div>
            </div>
            {previewUrl && (
              <div className="space-y-2">
                <div className="flex items-center justify-between text-xs font-medium text-muted-foreground">
                  <span className="flex items-center gap-2">
                    <Server className="h-3 w-3" /> Live preview
                  </span>
                  <Badge variant="outline" className="text-[10px] uppercase tracking-wide">
                    Forwarded
                  </Badge>
                </div>
                <div className="aspect-video overflow-hidden rounded-lg border border-border/40 bg-background/60">
                  <iframe src={previewUrl} title="WebContainer preview" className="h-full w-full border-0 bg-white" />
                </div>
              </div>
            )}
            {pythonPreviewHtml && (
              <div className="space-y-2">
                <div className="flex items-center justify-between text-xs font-medium text-muted-foreground">
                  <span className="flex items-center gap-2">
                    <Server className="h-3 w-3" /> Rendered HTML preview
                  </span>
                  <Badge variant="outline" className="text-[10px] uppercase tracking-wide">
                    Generated
                  </Badge>
                </div>
                <div className="aspect-video overflow-hidden rounded-lg border border-border/40 bg-background/60">
                  <iframe srcDoc={pythonPreviewHtml} title="Python preview" className="h-full w-full border-0 bg-white" />
                </div>
              </div>
            )}
          </>
        )}
      </CardContent>
    </Card>
  );
};

export default PrismAgentTerminal;
