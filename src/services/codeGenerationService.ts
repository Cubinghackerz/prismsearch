import { supabase } from '@/integrations/supabase/client';

export interface GeneratedFile {
  path: string;
  language: string;
  content: string;
  description?: string;
}

export interface CodeGenerationStack {
  language: string;
  framework: string;
  libraries: string[];
  tooling?: string[];
  notes?: string;
}

export interface CodeGenerationPlanStep {
  title: string;
  detail: string;
}

export interface CodeGenerationPlanPage {
  name: string;
  description: string;
}

export interface CodeGenerationPlanPreview {
  strategy: string;
  cdnDependencies: string[];
  notes: string[];
}

export interface CodeGenerationPlan {
  summary: string;
  goals: string[];
  stack: CodeGenerationStack;
  features: string[];
  pages: CodeGenerationPlanPage[];
  steps: CodeGenerationPlanStep[];
  preview: CodeGenerationPlanPreview;
  risks?: string[];
  testing?: string[];
}

export interface GeneratedApp {
  html: string;
  css: string;
  javascript: string;
  description: string;
  features: string[];
  previewHtml?: string;
  stack?: CodeGenerationStack;
  files?: GeneratedFile[];
}

export interface GenerateWebAppOptions {
  prompt: string;
  model: string;
  chatId: string;
  fallbackModels?: string[];
  plan?: CodeGenerationPlan;
}

export interface GenerateWebAppResult {
  app: GeneratedApp;
  usedModel: string;
  rawResponse: string;
}

export interface GenerateCodePlanOptions {
  prompt: string;
  model: string;
  chatId: string;
  fallbackModels?: string[];
}

export interface GenerateCodePlanResult {
  plan: CodeGenerationPlan;
  usedModel: string;
  rawResponse: string;
}

export const DEFAULT_CODE_GENERATION_FALLBACK_ORDER: string[] = [
  'gemini-2.5-pro',
  'gemini',
  'groq-llama4-maverick',
  'groq-llama4-scout',
  'groq-llama31-8b-instant',
];

const FALLBACK_PREVIEW_HTML = (content: string, css: string, js: string) => `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Generated Web App</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #0f172a;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      color: #e2e8f0;
    }
    .container {
      max-width: 960px;
      margin: 0 auto;
      background: rgba(15, 23, 42, 0.8);
      border-radius: 16px;
      padding: 32px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.45);
    }
    h1 {
      margin-top: 0;
    }
    ${css}
  </style>
</head>
<body>
  ${content}
  <script>
    try {
      ${js}
    } catch (error) {
      console.error('Preview error', error);
      const warning = document.createElement('div');
      warning.style.cssText = 'margin-top: 24px; padding: 16px; border-radius: 12px; background: rgba(239,68,68,0.15); color: #fecaca;';
      warning.innerText = 'Runtime error: ' + error.message;
      document.body.appendChild(warning);
    }
  </script>
</body>
</html>`;

const FALLBACK_APP: GeneratedApp = {
  html: `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Generated Web App</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <h1>Generated Web Application</h1>
    <div class="content">This application was generated by the AI assistant.</div>
  </div>
  <script src="script.js"></script>
</body>
</html>`,
  css: `body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 20px;
  background-color: #0f172a;
  color: #e2e8f0;
}
.container {
  max-width: 800px;
  margin: 0 auto;
  background: rgba(15, 23, 42, 0.8);
  padding: 24px;
  border-radius: 16px;
  box-shadow: 0 12px 30px rgba(15, 23, 42, 0.45);
}
.content {
  margin-top: 20px;
  line-height: 1.6;
}`,
  javascript: "console.log('Web app generated successfully');",
  description: 'AI-generated web application',
  features: ['Responsive design', 'Modern styling', 'Basic functionality'],
  previewHtml: FALLBACK_PREVIEW_HTML(
    '<div class="container"><h1>Generated Web Application</h1><div class="content">This application was generated by the AI assistant.</div></div>',
    `body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #0f172a; color: #e2e8f0; }`,
    "console.log('Preview ready');"
  ),
  stack: {
    language: 'JavaScript',
    framework: 'Vanilla',
    libraries: [],
    tooling: [],
    notes: 'Fallback stack using vanilla JavaScript for in-browser preview.'
  },
};

const isRecord = (value: unknown): value is Record<string, unknown> => {
  return typeof value === 'object' && value !== null;
};

const buildPlanPrompt = (description: string): string => {
  return `You are Prism's senior AI architect. Create a concise, practical development plan for a web experience described as: "${description}".

Return ONLY valid JSON with this exact structure:
{
  "summary": "one paragraph overview",
  "goals": ["concise goal", "another goal"],
  "stack": {
    "language": "primary language (e.g. TypeScript)",
    "framework": "primary framework or 'Vanilla'",
    "libraries": ["library or CDN"],
    "tooling": ["tool or build helper"],
    "notes": "practical notes about the stack"
  },
  "features": ["notable feature", "another feature"],
  "pages": [
    {
      "name": "Page or component name",
      "description": "What it does"
    }
  ],
  "steps": [
    {
      "title": "Step title",
      "detail": "What is implemented in this step"
    }
  ],
  "preview": {
    "strategy": "How to render this in a single in-browser preview",
    "cdnDependencies": ["cdn url or package"],
    "notes": ["preview caveat or requirement"]
  },
  "risks": ["optional risk"],
  "testing": ["optional testing note"]
}

The plan must select stacks that work without custom build tooling on the client. If a framework is chosen, rely on CDN or in-browser tooling so Prism's preview can run immediately.`;
};

const buildGenerationPrompt = (description: string, plan?: CodeGenerationPlan): string => {
  const planContext = plan
    ? `Follow this approved implementation plan (JSON):\n${JSON.stringify(plan)}\nRespect the chosen language, framework, libraries, and preview strategy. Reflect the features, pages, and steps in the implementation.`
    : 'Select an appropriate lightweight stack, outline your approach, and ensure it can run in-browser without bundling.';

  return `You are Prism's web application generator. ${planContext}

Generate a complete project that runs directly in the browser. If the stack requires frameworks, TypeScript, or JSX, include browser-friendly builds via CDN or inline transpilation so the preview works.

Return ONLY valid JSON with this structure:
{
  "html": "base HTML shell (can reference external scripts and styles)",
  "css": "global styles (can be empty string)",
  "javascript": "main inline script or bootstrap logic",
  "description": "short summary of the delivered experience",
  "features": ["feature"],
  "previewHtml": "FULL standalone HTML document for live preview with all dependencies",
  "stack": {
    "language": "language used",
    "framework": "framework or 'Vanilla'",
    "libraries": ["libraries or cdn"],
    "tooling": ["optional tooling"],
    "notes": "stack notes"
  },
  "files": [
    {"path": "src/App.tsx", "language": "typescript", "content": "file contents", "description": "purpose"}
  ]
}

Ensure previewHtml is immediately runnable and loads every dependency declared in stack.libraries and preview.cdnDependencies (if provided). Include additional framework files in the files array so the user can continue development.`;
};

const sanitizeJsonResponse = (responseText: string): string => {
  return responseText.replace(/```json\n?|```\n?/g, '').trim();
};

const fallbackPlanForPrompt = (prompt: string): CodeGenerationPlan => ({
  summary: `AI-generated plan for: ${prompt}`,
  goals: [prompt],
  stack: {
    language: 'JavaScript',
    framework: 'Vanilla',
    libraries: ['https://cdn.jsdelivr.net/npm/tailwindcss@3/dist/tailwind.min.css'],
    tooling: [],
    notes: 'Fallback plan generated because the model response could not be parsed.'
  },
  features: ['Responsive layout', 'Interactive components'],
  pages: [
    {
      name: 'Main Page',
      description: 'Single page experience built from fallback plan.'
    }
  ],
  steps: [
    { title: 'Structure layout', detail: 'Define HTML structure and responsive containers.' },
    { title: 'Style interface', detail: 'Apply Tailwind utility classes for styling.' },
    { title: 'Wire interactions', detail: 'Use vanilla JavaScript for interactions.' }
  ],
  preview: {
    strategy: 'Vanilla HTML/CSS/JS served in a single document.',
    cdnDependencies: ['https://cdn.jsdelivr.net/npm/tailwindcss@3/dist/tailwind.min.css'],
    notes: ['Fallback preview generated because the plan response was malformed.']
  },
  risks: ['Automatic plan parsing failed, so manual review recommended.'],
  testing: ['Manually verify layout and interactions.']
});

const parseCodePlan = (responseText: string, prompt: string): CodeGenerationPlan => {
  const cleanResponse = sanitizeJsonResponse(responseText);
  const fallbackPlan = fallbackPlanForPrompt(prompt);

  try {
    const parsed = JSON.parse(cleanResponse);
    const stack = parsed.stack && typeof parsed.stack === 'object'
      ? {
          language: String(parsed.stack.language ?? fallbackPlan.stack.language),
          framework: String(parsed.stack.framework ?? fallbackPlan.stack.framework),
          libraries: Array.isArray(parsed.stack.libraries)
            ? parsed.stack.libraries.map((item: unknown) => String(item))
            : fallbackPlan.stack.libraries,
          tooling: Array.isArray(parsed.stack.tooling)
            ? parsed.stack.tooling.map((item: unknown) => String(item))
            : [],
          notes: typeof parsed.stack.notes === 'string' ? parsed.stack.notes : fallbackPlan.stack.notes,
        }
      : fallbackPlan.stack;

    const plan: CodeGenerationPlan = {
      summary: typeof parsed.summary === 'string' ? parsed.summary : fallbackPlan.summary,
      goals: Array.isArray(parsed.goals)
        ? parsed.goals.map((item: unknown) => String(item))
        : fallbackPlan.goals,
      stack,
      features: Array.isArray(parsed.features)
        ? parsed.features.map((item: unknown) => String(item))
        : fallbackPlan.features,
      pages: Array.isArray(parsed.pages)
        ? parsed.pages
            .filter((item: unknown): item is Record<string, unknown> => isRecord(item))
            .map((item) => ({
              name: typeof item.name === 'string' ? item.name : 'Page',
              description: typeof item.description === 'string' ? item.description : '',
            }))
        : fallbackPlan.pages,
      steps: Array.isArray(parsed.steps)
        ? parsed.steps
            .filter((item: unknown): item is Record<string, unknown> => isRecord(item))
            .map((item) => ({
              title: typeof item.title === 'string' ? item.title : 'Step',
              detail: typeof item.detail === 'string' ? item.detail : '',
            }))
        : fallbackPlan.steps,
      preview: parsed.preview && typeof parsed.preview === 'object'
        ? {
            strategy: String(parsed.preview.strategy ?? fallbackPlan.preview.strategy),
            cdnDependencies: Array.isArray(parsed.preview.cdnDependencies)
              ? parsed.preview.cdnDependencies.map((item: unknown) => String(item))
              : fallbackPlan.preview.cdnDependencies,
            notes: Array.isArray(parsed.preview.notes)
              ? parsed.preview.notes.map((item: unknown) => String(item))
              : fallbackPlan.preview.notes,
          }
        : fallbackPlan.preview,
      risks: Array.isArray(parsed.risks)
        ? parsed.risks.map((item: unknown) => String(item))
        : fallbackPlan.risks,
      testing: Array.isArray(parsed.testing)
        ? parsed.testing.map((item: unknown) => String(item))
        : fallbackPlan.testing,
    };

    return plan;
  } catch (error) {
    return fallbackPlan;
  }
};

const parseGeneratedApp = (responseText: string): GeneratedApp => {
  const cleanResponse = sanitizeJsonResponse(responseText);

  try {
    const parsed = JSON.parse(cleanResponse);
    const features = Array.isArray(parsed.features)
      ? parsed.features.map((item: unknown) => String(item))
      : FALLBACK_APP.features;

    const stack = parsed.stack && typeof parsed.stack === 'object'
      ? {
          language: String(parsed.stack.language ?? ''),
          framework: String(parsed.stack.framework ?? ''),
          libraries: Array.isArray(parsed.stack.libraries)
            ? parsed.stack.libraries.map((item: unknown) => String(item))
            : [],
          tooling: Array.isArray(parsed.stack.tooling)
            ? parsed.stack.tooling.map((item: unknown) => String(item))
            : [],
          notes: typeof parsed.stack.notes === 'string' ? parsed.stack.notes : undefined,
        }
      : undefined;

    const files = Array.isArray(parsed.files)
      ? parsed.files
          .filter((item: unknown): item is Record<string, unknown> => isRecord(item))
          .map((item) => ({
            path: typeof item.path === 'string' ? item.path : '',
            language: typeof item.language === 'string' ? item.language : 'plaintext',
            content: typeof item.content === 'string' ? item.content : '',
            description: typeof item.description === 'string' ? item.description : undefined,
          }))
          .filter((file: GeneratedFile) => file.path.length > 0)
      : undefined;

    const html = typeof parsed.html === 'string' ? parsed.html : FALLBACK_APP.html;
    const css = typeof parsed.css === 'string' ? parsed.css : FALLBACK_APP.css;
    const javascript = typeof parsed.javascript === 'string' ? parsed.javascript : FALLBACK_APP.javascript;

    return {
      html,
      css,
      javascript,
      description: typeof parsed.description === 'string' ? parsed.description : FALLBACK_APP.description,
      features,
      previewHtml: typeof parsed.previewHtml === 'string'
        ? parsed.previewHtml
        : FALLBACK_PREVIEW_HTML(html, css, javascript),
      stack,
      files,
    };
  } catch (error) {
    const sanitizedText = responseText.replace(/\n/g, '<br>');
    return {
      ...FALLBACK_APP,
      html: FALLBACK_APP.html.replace(
        '<div class="content">This application was generated by the AI assistant.</div>',
        `<div class="content">${sanitizedText}</div>`
      ),
      previewHtml: FALLBACK_PREVIEW_HTML(
        `<div class="container"><h1>Generation Error</h1><div class="content">${sanitizedText}</div></div>`,
        FALLBACK_APP.css,
        FALLBACK_APP.javascript
      ),
    };
  }
};

const invokeGeneration = async (query: string, model: string, chatId: string) => {
  const { data, error } = await supabase.functions.invoke('ai-search-assistant', {
    body: {
      query,
      model,
      chatId,
      chatHistory: [],
    },
  });

  if (error) {
    throw new Error(error.message);
  }

  return data?.response || '';
};

export const generateCodePlan = async ({
  prompt,
  model,
  chatId,
  fallbackModels = DEFAULT_CODE_GENERATION_FALLBACK_ORDER,
}: GenerateCodePlanOptions): Promise<GenerateCodePlanResult> => {
  const modelsToTry = [model, ...fallbackModels.filter((fallback) => fallback !== model)];
  let lastError: Error | null = null;

  for (const currentModel of modelsToTry) {
    try {
      const rawResponse = await invokeGeneration(buildPlanPrompt(prompt), currentModel, chatId);
      const plan = parseCodePlan(rawResponse || '', prompt);
      return {
        plan,
        usedModel: currentModel,
        rawResponse,
      };
    } catch (error) {
      lastError = error instanceof Error ? error : new Error('Unknown error generating development plan');
    }
  }

  throw lastError || new Error('Failed to generate a development plan with the available models');
};

export const generateWebApp = async ({
  prompt,
  model,
  chatId,
  fallbackModels = DEFAULT_CODE_GENERATION_FALLBACK_ORDER,
  plan,
}: GenerateWebAppOptions): Promise<GenerateWebAppResult> => {
  const modelsToTry = [model, ...fallbackModels.filter((fallback) => fallback !== model)];
  let lastError: Error | null = null;

  const generationPrompt = buildGenerationPrompt(prompt, plan);

  for (const currentModel of modelsToTry) {
    try {
      const rawResponse = await invokeGeneration(generationPrompt, currentModel, chatId);
      const app = parseGeneratedApp(rawResponse || '');
      return {
        app,
        usedModel: currentModel,
        rawResponse,
      };
    } catch (error) {
      lastError = error instanceof Error ? error : new Error('Unknown error generating web app');
    }
  }

  throw lastError || new Error('Failed to generate web app with the available models');
};
